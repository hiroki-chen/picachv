// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByProxy {
    /// The vectors of indexes that are used to group the data.
    #[prost(uint64, repeated, tag = "1")]
    pub first: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<group_by_proxy::Groups>,
}
/// Nested message and enum types in `GroupByProxy`.
pub mod group_by_proxy {
    /// Groups belonging to the same group.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Groups {
        #[prost(uint64, repeated, tag = "1")]
        pub group: ::prost::alloc::vec::Vec<u64>,
    }
}
/// A value that incorporates any primitive data types.
///
/// Note that there is no `u8`, `u16` type in protobuf so we use a tag to
/// differentiate between the different types.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrimitiveValue {
    #[prost(
        oneof = "primitive_value::Value",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"
    )]
    pub value: ::core::option::Option<primitive_value::Value>,
}
/// Nested message and enum types in `PrimitiveValue`.
pub mod primitive_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Duration {
        #[prost(int64, tag = "1")]
        pub sec: i64,
        #[prost(int32, tag = "2")]
        pub nsec: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(uint32, tag = "1")]
        U8(u32),
        #[prost(uint32, tag = "2")]
        U16(u32),
        #[prost(uint32, tag = "3")]
        U32(u32),
        #[prost(uint64, tag = "4")]
        U64(u64),
        #[prost(int32, tag = "5")]
        I8(i32),
        #[prost(int32, tag = "6")]
        I16(i32),
        #[prost(int32, tag = "7")]
        I32(i32),
        #[prost(int64, tag = "8")]
        I64(i64),
        #[prost(float, tag = "9")]
        F32(f32),
        #[prost(double, tag = "10")]
        F64(f64),
        #[prost(bool, tag = "11")]
        Bool(bool),
        #[prost(string, tag = "12")]
        Str(::prost::alloc::string::String),
        #[prost(message, tag = "13")]
        Duration(Duration),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryOperator {
    #[prost(oneof = "binary_operator::Operator", tags = "1, 2, 3")]
    pub operator: ::core::option::Option<binary_operator::Operator>,
}
/// Nested message and enum types in `BinaryOperator`.
pub mod binary_operator {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operator {
        #[prost(enumeration = "super::LogicalBinaryOperator", tag = "1")]
        LogicalOperator(i32),
        #[prost(enumeration = "super::ComparisonBinaryOperator", tag = "2")]
        ComparisonOperator(i32),
        #[prost(enumeration = "super::ArithmeticBinaryOperator", tag = "3")]
        ArithmeticOperator(i32),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileType {
    Csv = 0,
    Parquet = 1,
    Json = 2,
    Avro = 3,
}
impl FileType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FileType::Csv => "Csv",
            FileType::Parquet => "Parquet",
            FileType::Json => "Json",
            FileType::Avro => "Avro",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Csv" => Some(Self::Csv),
            "Parquet" => Some(Self::Parquet),
            "Json" => Some(Self::Json),
            "Avro" => Some(Self::Avro),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JoinType {
    Inner = 0,
    Left = 1,
    Cross = 2,
    Outer = 3,
}
impl JoinType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            JoinType::Inner => "Inner",
            JoinType::Left => "Left",
            JoinType::Cross => "Cross",
            JoinType::Outer => "Outer",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Inner" => Some(Self::Inner),
            "Left" => Some(Self::Left),
            "Cross" => Some(Self::Cross),
            "Outer" => Some(Self::Outer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogicalPlanType {
    Select = 0,
    Distinct = 1,
    Projection = 2,
    Aggregation = 3,
    Join = 4,
    Scan = 5,
    Union = 6,
    Other = 7,
}
impl LogicalPlanType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogicalPlanType::Select => "Select",
            LogicalPlanType::Distinct => "Distinct",
            LogicalPlanType::Projection => "Projection",
            LogicalPlanType::Aggregation => "Aggregation",
            LogicalPlanType::Join => "Join",
            LogicalPlanType::Scan => "Scan",
            LogicalPlanType::Union => "Union",
            LogicalPlanType::Other => "Other",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Select" => Some(Self::Select),
            "Distinct" => Some(Self::Distinct),
            "Projection" => Some(Self::Projection),
            "Aggregation" => Some(Self::Aggregation),
            "Join" => Some(Self::Join),
            "Scan" => Some(Self::Scan),
            "Union" => Some(Self::Union),
            "Other" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogicalBinaryOperator {
    And = 0,
    Or = 1,
}
impl LogicalBinaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogicalBinaryOperator::And => "And",
            LogicalBinaryOperator::Or => "Or",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "And" => Some(Self::And),
            "Or" => Some(Self::Or),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComparisonBinaryOperator {
    Eq = 0,
    Ne = 1,
    Gt = 2,
    Lt = 3,
    Le = 4,
    Ge = 5,
}
impl ComparisonBinaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ComparisonBinaryOperator::Eq => "Eq",
            ComparisonBinaryOperator::Ne => "Ne",
            ComparisonBinaryOperator::Gt => "Gt",
            ComparisonBinaryOperator::Lt => "Lt",
            ComparisonBinaryOperator::Le => "Le",
            ComparisonBinaryOperator::Ge => "Ge",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Eq" => Some(Self::Eq),
            "Ne" => Some(Self::Ne),
            "Gt" => Some(Self::Gt),
            "Lt" => Some(Self::Lt),
            "Le" => Some(Self::Le),
            "Ge" => Some(Self::Ge),
            _ => None,
        }
    }
}
/// We only need to tell Picachv what we are trying to do currently.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArithmeticBinaryOperator {
    Add = 0,
    Sub = 1,
    Mul = 2,
    Div = 3,
    Mod = 4,
    Pow = 5,
    ShiftBy = 6,
}
impl ArithmeticBinaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ArithmeticBinaryOperator::Add => "Add",
            ArithmeticBinaryOperator::Sub => "Sub",
            ArithmeticBinaryOperator::Mul => "Mul",
            ArithmeticBinaryOperator::Div => "Div",
            ArithmeticBinaryOperator::Mod => "Mod",
            ArithmeticBinaryOperator::Pow => "Pow",
            ArithmeticBinaryOperator::ShiftBy => "ShiftBy",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Add" => Some(Self::Add),
            "Sub" => Some(Self::Sub),
            "Mul" => Some(Self::Mul),
            "Div" => Some(Self::Div),
            "Mod" => Some(Self::Mod),
            "Pow" => Some(Self::Pow),
            "ShiftBy" => Some(Self::ShiftBy),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnaryOperator {
    Identity = 0,
    Redact = 1,
    Substitute = 2,
    Not = 3,
}
impl UnaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UnaryOperator::Identity => "Identity",
            UnaryOperator::Redact => "Redact",
            UnaryOperator::Substitute => "Substitute",
            UnaryOperator::Not => "Not",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Identity" => Some(Self::Identity),
            "Redact" => Some(Self::Redact),
            "Substitute" => Some(Self::Substitute),
            "Not" => Some(Self::Not),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupByMethod {
    Min = 0,
    NanMin = 1,
    Max = 2,
    NanMax = 3,
    Median = 4,
    Mean = 5,
    First = 6,
    Last = 7,
    Sum = 8,
}
impl GroupByMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GroupByMethod::Min => "Min",
            GroupByMethod::NanMin => "NanMin",
            GroupByMethod::Max => "Max",
            GroupByMethod::NanMax => "NanMax",
            GroupByMethod::Median => "Median",
            GroupByMethod::Mean => "Mean",
            GroupByMethod::First => "First",
            GroupByMethod::Last => "Last",
            GroupByMethod::Sum => "Sum",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Min" => Some(Self::Min),
            "NanMin" => Some(Self::NanMin),
            "Max" => Some(Self::Max),
            "NanMax" => Some(Self::NanMax),
            "Median" => Some(Self::Median),
            "Mean" => Some(Self::Mean),
            "First" => Some(Self::First),
            "Last" => Some(Self::Last),
            "Sum" => Some(Self::Sum),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExprType {
    Agg = 0,
    Column = 1,
    Count = 2,
    Alias = 3,
    Wildcard = 4,
    Filter = 5,
    Binary = 6,
    Unary = 7,
}
impl ExprType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExprType::Agg => "Agg",
            ExprType::Column => "Column",
            ExprType::Count => "Count",
            ExprType::Alias => "Alias",
            ExprType::Wildcard => "Wildcard",
            ExprType::Filter => "Filter",
            ExprType::Binary => "Binary",
            ExprType::Unary => "Unary",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Agg" => Some(Self::Agg),
            "Column" => Some(Self::Column),
            "Count" => Some(Self::Count),
            "Alias" => Some(Self::Alias),
            "Wildcard" => Some(Self::Wildcard),
            "Filter" => Some(Self::Filter),
            "Binary" => Some(Self::Binary),
            "Unary" => Some(Self::Unary),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "GroupByMethod", tag = "2")]
    pub method: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnExpr {
    #[prost(oneof = "column_expr::Column", tags = "1, 2")]
    pub column: ::core::option::Option<column_expr::Column>,
}
/// Nested message and enum types in `ColumnExpr`.
pub mod column_expr {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ColumnNameSpecifier {
        #[prost(string, tag = "1")]
        pub column_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Column {
        #[prost(uint64, tag = "1")]
        ColumnId(u64),
        /// This can be problematic since it relies solely on the column name
        #[prost(message, tag = "2")]
        ColumnNameSpecifier(ColumnNameSpecifier),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AliasExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub alias: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WildcardExpr {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiteralExpr {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub filter_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub left_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub right_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub op: ::core::option::Option<BinaryOperator>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnaryExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "UnaryOperator", tag = "2")]
    pub op: i32,
}
/// Function application.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyExpr {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub input_uuids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExprArgument {
    #[prost(oneof = "expr_argument::Argument", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
    pub argument: ::core::option::Option<expr_argument::Argument>,
}
/// Nested message and enum types in `ExprArgument`.
pub mod expr_argument {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Argument {
        #[prost(message, tag = "1")]
        Agg(super::AggExpr),
        #[prost(message, tag = "2")]
        Column(super::ColumnExpr),
        #[prost(message, tag = "3")]
        Alias(super::AliasExpr),
        #[prost(message, tag = "4")]
        Wildcard(super::WildcardExpr),
        #[prost(message, tag = "5")]
        Filter(super::FilterExpr),
        #[prost(message, tag = "6")]
        Binary(super::BinaryExpr),
        #[prost(message, tag = "7")]
        Unary(super::UnaryExpr),
        #[prost(message, tag = "8")]
        Literal(super::LiteralExpr),
        #[prost(message, tag = "9")]
        Apply(super::ApplyExpr),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataFromFileArgument {
    /// The path to the file.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// The type of the file.
    #[prost(enumeration = "FileType", tag = "2")]
    pub file_type: i32,
    /// The schema of the file.
    ///
    /// Note that the caller must ensure that the schema itself is registered!
    #[prost(bytes = "vec", tag = "3")]
    pub df_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataInMemory {
    #[prost(bytes = "vec", tag = "1")]
    pub df_uuid: ::prost::alloc::vec::Vec<u8>,
    /// In case we will have the "selection pushdown" thing.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub pred: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// In case we will have the "projection pushdown" thing.
    #[prost(string, repeated, tag = "3")]
    pub projected_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataArgument {
    #[prost(oneof = "get_data_argument::DataSource", tags = "1, 2")]
    pub data_source: ::core::option::Option<get_data_argument::DataSource>,
}
/// Nested message and enum types in `GetDataArgument`.
pub mod get_data_argument {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataSource {
        #[prost(message, tag = "1")]
        FromFile(super::GetDataFromFileArgument),
        #[prost(message, tag = "2")]
        InMemory(super::GetDataInMemory),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectArgument {
    /// The uuid of the predicate.
    #[prost(bytes = "vec", tag = "1")]
    pub pred_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionArgument {
    /// Column 'names' as we may apply some transformation on columns.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub expression: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateArgument {
    /// The uuid of the group by.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub aggs_uuid: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, tag = "3")]
    pub maintain_order: bool,
    #[prost(message, optional, tag = "4")]
    pub group_by_proxy: ::core::option::Option<GroupByProxy>,
    #[prost(string, repeated, tag = "5")]
    pub output_schema: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A Rust `enum`-like message to represent the different types of physical
/// plans.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanArgument {
    #[prost(oneof = "plan_argument::Argument", tags = "1, 2, 3, 4")]
    pub argument: ::core::option::Option<plan_argument::Argument>,
}
/// Nested message and enum types in `PlanArgument`.
pub mod plan_argument {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Argument {
        #[prost(message, tag = "1")]
        Select(super::SelectArgument),
        #[prost(message, tag = "2")]
        Projection(super::ProjectionArgument),
        #[prost(message, tag = "3")]
        Aggregate(super::AggregateArgument),
        #[prost(message, tag = "4")]
        GetData(super::GetDataArgument),
    }
}
/// This message is used to notify the monitor which rows are dropped.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterInformation {
    #[prost(bytes = "vec", tag = "1")]
    pub df_uuid: ::prost::alloc::vec::Vec<u8>,
    /// A boolean array that indicates which rows are dropped (0 dropped; 1 not
    /// dropped). The index is in correspondence with the original relation, i.e.,
    /// filter\[idx\] = 1 means the idx-th row is not dropped.
    #[prost(bool, repeated, tag = "2")]
    pub filter: ::prost::alloc::vec::Vec<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinInformation {
    /// The UUID of the left relation.
    #[prost(bytes = "vec", tag = "1")]
    pub lhs_df_uuid: ::prost::alloc::vec::Vec<u8>,
    /// The UUID of the right relation.
    #[prost(bytes = "vec", tag = "2")]
    pub rhs_df_uuid: ::prost::alloc::vec::Vec<u8>,
    /// The lhs columns that are used to join the two relations.
    #[prost(string, repeated, tag = "3")]
    pub left_on: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The rhs columns that are used to join the two relations.
    #[prost(string, repeated, tag = "4")]
    pub right_on: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The information of each row in the joined relation.
    #[prost(message, repeated, tag = "5")]
    pub row_join_info: ::prost::alloc::vec::Vec<join_information::RowJoinInformation>,
    /// Output schema.
    #[prost(string, repeated, tag = "6")]
    pub output_schema: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `JoinInformation`.
pub mod join_information {
    /// This message is used to describe for each row in the joined
    /// relation, which rows in the left and right relations are used to join.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RowJoinInformation {
        #[prost(uint64, tag = "1")]
        pub left_rows: u64,
        #[prost(uint64, tag = "2")]
        pub right_rows: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByInformation {
    #[prost(bytes = "vec", tag = "1")]
    pub df_uuid: ::prost::alloc::vec::Vec<u8>,
    /// Tells the monitor which row is aggregated.
    #[prost(map = "uint64, uint64", tag = "2")]
    pub group_by: ::std::collections::HashMap<u64, u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionInformation {
    #[prost(bytes = "vec", tag = "1")]
    pub lhs_df_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub rhs_df_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReorderInformation {
    #[prost(bytes = "vec", tag = "1")]
    pub df_uuid: ::prost::alloc::vec::Vec<u8>,
    /// The permutation of rows in case reorder occurs.
    #[prost(uint64, repeated, tag = "2")]
    pub perm: ::prost::alloc::vec::Vec<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformInfo {
    /// An array of information telling the monitor what has been done.
    #[prost(message, repeated, tag = "1")]
    pub trans_info: ::prost::alloc::vec::Vec<transform_info::Information>,
}
/// Nested message and enum types in `TransformInfo`.
pub mod transform_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Information {
        #[prost(oneof = "information::Information", tags = "1, 2, 3, 4, 5")]
        pub information: ::core::option::Option<information::Information>,
    }
    /// Nested message and enum types in `Information`.
    pub mod information {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Information {
            #[prost(message, tag = "1")]
            Filter(super::super::FilterInformation),
            #[prost(message, tag = "2")]
            Join(super::super::JoinInformation),
            #[prost(message, tag = "3")]
            GroupBy(super::super::GroupByInformation),
            #[prost(message, tag = "4")]
            Reorder(super::super::ReorderInformation),
            #[prost(message, tag = "5")]
            Union(super::super::UnionInformation),
        }
    }
}
