// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryOperator {
    #[prost(oneof = "binary_operator::Operator", tags = "1, 2, 3")]
    pub operator: ::core::option::Option<binary_operator::Operator>,
}
/// Nested message and enum types in `BinaryOperator`.
pub mod binary_operator {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operator {
        #[prost(enumeration = "super::LogicalBinaryOperator", tag = "1")]
        LogicalOperator(i32),
        #[prost(enumeration = "super::ComparisonBinaryOperator", tag = "2")]
        ComparisonOperator(i32),
        #[prost(enumeration = "super::ArithmeticBinaryOperator", tag = "3")]
        ArithmeticOperator(i32),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileType {
    Csv = 0,
    Parquet = 1,
    Json = 2,
    Avro = 3,
}
impl FileType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FileType::Csv => "Csv",
            FileType::Parquet => "Parquet",
            FileType::Json => "Json",
            FileType::Avro => "Avro",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Csv" => Some(Self::Csv),
            "Parquet" => Some(Self::Parquet),
            "Json" => Some(Self::Json),
            "Avro" => Some(Self::Avro),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JoinType {
    Inner = 0,
    Left = 1,
    Right = 2,
    Outer = 3,
}
impl JoinType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            JoinType::Inner => "Inner",
            JoinType::Left => "Left",
            JoinType::Right => "Right",
            JoinType::Outer => "Outer",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Inner" => Some(Self::Inner),
            "Left" => Some(Self::Left),
            "Right" => Some(Self::Right),
            "Outer" => Some(Self::Outer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogicalPlanType {
    Select = 0,
    Distinct = 1,
    Projection = 2,
    Aggregation = 3,
    Join = 4,
    Scan = 5,
    Union = 6,
    Other = 7,
}
impl LogicalPlanType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogicalPlanType::Select => "Select",
            LogicalPlanType::Distinct => "Distinct",
            LogicalPlanType::Projection => "Projection",
            LogicalPlanType::Aggregation => "Aggregation",
            LogicalPlanType::Join => "Join",
            LogicalPlanType::Scan => "Scan",
            LogicalPlanType::Union => "Union",
            LogicalPlanType::Other => "Other",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Select" => Some(Self::Select),
            "Distinct" => Some(Self::Distinct),
            "Projection" => Some(Self::Projection),
            "Aggregation" => Some(Self::Aggregation),
            "Join" => Some(Self::Join),
            "Scan" => Some(Self::Scan),
            "Union" => Some(Self::Union),
            "Other" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogicalBinaryOperator {
    And = 0,
    Or = 1,
}
impl LogicalBinaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogicalBinaryOperator::And => "And",
            LogicalBinaryOperator::Or => "Or",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "And" => Some(Self::And),
            "Or" => Some(Self::Or),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComparisonBinaryOperator {
    Eq = 0,
    Ne = 1,
    Gt = 2,
    Lt = 3,
    Le = 4,
    Ge = 5,
}
impl ComparisonBinaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ComparisonBinaryOperator::Eq => "Eq",
            ComparisonBinaryOperator::Ne => "Ne",
            ComparisonBinaryOperator::Gt => "Gt",
            ComparisonBinaryOperator::Lt => "Lt",
            ComparisonBinaryOperator::Le => "Le",
            ComparisonBinaryOperator::Ge => "Ge",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Eq" => Some(Self::Eq),
            "Ne" => Some(Self::Ne),
            "Gt" => Some(Self::Gt),
            "Lt" => Some(Self::Lt),
            "Le" => Some(Self::Le),
            "Ge" => Some(Self::Ge),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArithmeticBinaryOperator {
    Add = 0,
    Sub = 1,
    Mul = 2,
    Div = 3,
    Mod = 4,
    Pow = 5,
}
impl ArithmeticBinaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ArithmeticBinaryOperator::Add => "Add",
            ArithmeticBinaryOperator::Sub => "Sub",
            ArithmeticBinaryOperator::Mul => "Mul",
            ArithmeticBinaryOperator::Div => "Div",
            ArithmeticBinaryOperator::Mod => "Mod",
            ArithmeticBinaryOperator::Pow => "Pow",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Add" => Some(Self::Add),
            "Sub" => Some(Self::Sub),
            "Mul" => Some(Self::Mul),
            "Div" => Some(Self::Div),
            "Mod" => Some(Self::Mod),
            "Pow" => Some(Self::Pow),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnaryOperator {
    Identity = 0,
    Redact = 1,
    Substitute = 2,
    Not = 3,
}
impl UnaryOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UnaryOperator::Identity => "Identity",
            UnaryOperator::Redact => "Redact",
            UnaryOperator::Substitute => "Substitute",
            UnaryOperator::Not => "Not",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Identity" => Some(Self::Identity),
            "Redact" => Some(Self::Redact),
            "Substitute" => Some(Self::Substitute),
            "Not" => Some(Self::Not),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupByMethod {
    Min = 0,
    NanMin = 1,
    Max = 2,
    NanMax = 3,
    Median = 4,
    Mean = 5,
    First = 6,
    Last = 7,
    Sum = 8,
}
impl GroupByMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GroupByMethod::Min => "Min",
            GroupByMethod::NanMin => "NanMin",
            GroupByMethod::Max => "Max",
            GroupByMethod::NanMax => "NanMax",
            GroupByMethod::Median => "Median",
            GroupByMethod::Mean => "Mean",
            GroupByMethod::First => "First",
            GroupByMethod::Last => "Last",
            GroupByMethod::Sum => "Sum",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Min" => Some(Self::Min),
            "NanMin" => Some(Self::NanMin),
            "Max" => Some(Self::Max),
            "NanMax" => Some(Self::NanMax),
            "Median" => Some(Self::Median),
            "Mean" => Some(Self::Mean),
            "First" => Some(Self::First),
            "Last" => Some(Self::Last),
            "Sum" => Some(Self::Sum),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExprType {
    Agg = 0,
    Column = 1,
    Count = 2,
    Alias = 3,
    Wildcard = 4,
    Filter = 5,
    Binary = 6,
    Unary = 7,
}
impl ExprType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExprType::Agg => "Agg",
            ExprType::Column => "Column",
            ExprType::Count => "Count",
            ExprType::Alias => "Alias",
            ExprType::Wildcard => "Wildcard",
            ExprType::Filter => "Filter",
            ExprType::Binary => "Binary",
            ExprType::Unary => "Unary",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Agg" => Some(Self::Agg),
            "Column" => Some(Self::Column),
            "Count" => Some(Self::Count),
            "Alias" => Some(Self::Alias),
            "Wildcard" => Some(Self::Wildcard),
            "Filter" => Some(Self::Filter),
            "Binary" => Some(Self::Binary),
            "Unary" => Some(Self::Unary),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub propagate_nans: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaxExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub propagate_nans: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeanExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirstExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LastExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggExpr {
    #[prost(oneof = "agg_expr::Expr", tags = "1, 2, 3, 4, 5, 6")]
    pub expr: ::core::option::Option<agg_expr::Expr>,
}
/// Nested message and enum types in `AggExpr`.
pub mod agg_expr {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Expr {
        #[prost(message, tag = "1")]
        Min(super::MinExpr),
        #[prost(message, tag = "2")]
        Max(super::MaxExpr),
        #[prost(message, tag = "3")]
        Sum(super::SumExpr),
        #[prost(message, tag = "4")]
        Mean(super::MeanExpr),
        #[prost(message, tag = "5")]
        First(super::FirstExpr),
        #[prost(message, tag = "6")]
        Last(super::LastExpr),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnExpr {
    #[prost(uint64, tag = "1")]
    pub column_id: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AliasExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub alias: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WildcardExpr {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub filter_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub left_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub right_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub op: ::core::option::Option<BinaryOperator>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnaryExpr {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "UnaryOperator", tag = "2")]
    pub op: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExprArgument {
    #[prost(oneof = "expr_argument::Argument", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub argument: ::core::option::Option<expr_argument::Argument>,
}
/// Nested message and enum types in `ExprArgument`.
pub mod expr_argument {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Argument {
        #[prost(message, tag = "1")]
        Agg(super::AggExpr),
        #[prost(message, tag = "2")]
        Column(super::ColumnExpr),
        #[prost(message, tag = "3")]
        Alias(super::AliasExpr),
        #[prost(message, tag = "4")]
        Wildcard(super::WildcardExpr),
        #[prost(message, tag = "5")]
        Filter(super::FilterExpr),
        #[prost(message, tag = "6")]
        Binary(super::BinaryExpr),
        #[prost(message, tag = "7")]
        Unary(super::UnaryExpr),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataFromFileArgument {
    /// The path to the file.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// The type of the file.
    #[prost(enumeration = "FileType", tag = "2")]
    pub file_type: i32,
    /// The schema of the file.
    ///
    /// Note that the caller must ensure that the schema itself is registered!
    #[prost(bytes = "vec", tag = "3")]
    pub schema_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataArgument {
    #[prost(oneof = "get_data_argument::DataSource", tags = "1")]
    pub data_source: ::core::option::Option<get_data_argument::DataSource>,
}
/// Nested message and enum types in `GetDataArgument`.
pub mod get_data_argument {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataSource {
        #[prost(message, tag = "1")]
        FromFile(super::GetDataFromFileArgument),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectArgument {
    /// The uuid of the input.
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    /// The uuid of the predicate.
    #[prost(bytes = "vec", tag = "2")]
    pub pred_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionArgument {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    /// Column 'names' as we may apply some transformation on columns.
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub expression: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The schema.
    #[prost(bytes = "vec", tag = "3")]
    pub schema_uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateArgument {
    #[prost(bytes = "vec", tag = "1")]
    pub input_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub schema_uuid: ::prost::alloc::vec::Vec<u8>,
    /// The uuid of the group by.
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", tag = "4")]
    pub aggs_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "5")]
    pub maintain_order: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinArgument {
    #[prost(bytes = "vec", tag = "1")]
    pub left_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub right_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub schema_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub left_on: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub right_on: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration = "JoinType", tag = "6")]
    pub join_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionArgument {
    #[prost(bytes = "vec", tag = "1")]
    pub left_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub right_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub schema_uuid: ::prost::alloc::vec::Vec<u8>,
}
/// A Rust `enum`-like message to represent the different types of physical plans.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanArgument {
    #[prost(oneof = "plan_argument::Argument", tags = "1, 2, 3, 4, 5, 6")]
    pub argument: ::core::option::Option<plan_argument::Argument>,
}
/// Nested message and enum types in `PlanArgument`.
pub mod plan_argument {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Argument {
        #[prost(message, tag = "1")]
        Select(super::SelectArgument),
        #[prost(message, tag = "2")]
        Projection(super::ProjectionArgument),
        #[prost(message, tag = "3")]
        Aggregate(super::AggregateArgument),
        #[prost(message, tag = "4")]
        Join(super::JoinArgument),
        #[prost(message, tag = "5")]
        Union(super::UnionArgument),
        #[prost(message, tag = "6")]
        GetData(super::GetDataArgument),
    }
}
/// This message is used to notify the monitor which rows are dropped.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterInformation {
    /// A boolean array that indicates which rows are dropped (0 dropped; 1 not
    /// dropped). The index is in correspondence with the original relation, i.e.,
    /// filter\[idx\] = 1 means the idx-th row is not dropped.
    #[prost(bool, repeated, tag = "1")]
    pub filter: ::prost::alloc::vec::Vec<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinInformation {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByInformation {
    /// Tells the monitor which row is aggregated.
    #[prost(map = "uint64, uint64", tag = "1")]
    pub group_by: ::std::collections::HashMap<u64, u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReorderInformation {
    /// The permutation of rows in case reorder occurs.
    #[prost(uint64, repeated, tag = "1")]
    pub perm: ::prost::alloc::vec::Vec<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformationInformation {
    /// An array of information telling the monitor what has been done.
    #[prost(message, repeated, tag = "1")]
    pub trans_info: ::prost::alloc::vec::Vec<transformation_information::Information>,
}
/// Nested message and enum types in `TransformationInformation`.
pub mod transformation_information {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Information {
        #[prost(oneof = "information::Information", tags = "1, 2, 3, 4")]
        pub information: ::core::option::Option<information::Information>,
    }
    /// Nested message and enum types in `Information`.
    pub mod information {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Information {
            #[prost(message, tag = "1")]
            Filter(super::super::FilterInformation),
            #[prost(message, tag = "2")]
            Join(super::super::JoinInformation),
            #[prost(message, tag = "3")]
            GroupBy(super::super::GroupByInformation),
            #[prost(message, tag = "4")]
            Reorder(super::super::ReorderInformation),
        }
    }
}
